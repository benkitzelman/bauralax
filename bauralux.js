// Generated by CoffeeScript 1.9.3
(function() {
  var Game, Team;

  Quintus.Math = function(Q) {
    Q.random = function(from, to) {
      return Math.floor(Math.random() * (to - from + 1) + from);
    };
    Q.normalizeAngle = function(angle) {
      var result;
      result = angle % 360;
      while (true) {
        if (result > 0) {
          break;
        }
        result = result + 360;
      }
      return result;
    };
    Q.angle = function(fromX, fromY, toX, toY) {
      var distX, distY, radians;
      distX = toX - fromX;
      distY = toY - fromY;
      radians = Math.atan2(distY, distX);
      return Q.radiansToDegrees(radians) - 90;
    };
    Q.distance = function(fromX, fromY, toX, toY) {
      if (toX == null) {
        toX = 0;
      }
      if (toY == null) {
        toY = 0;
      }
      return Math.sqrt(Math.pow(fromX - toX, 2) + Math.pow(fromY - toY, 2));
    };
    Q.offsetX = function(angle, radius) {
      return Math.sin(angle / 180 * Math.PI) * radius;
    };
    Q.offsetY = function(angle, radius) {
      return -Math.cos(angle / 180 * Math.PI) * radius;
    };
    Q.degreesToRadians = function(degrees) {
      return degrees * (Math.PI / 180);
    };
    return Q.radiansToDegrees = function(radians) {
      return radians * (180 / Math.PI);
    };
  };

  Team = (function() {
    Team.NONE = new Team({
      name: "None",
      rgb: [65, 65, 65]
    });

    Team.RED = new Team({
      name: "Red",
      rgb: [255, 0, 0]
    });

    Team.GREEN = new Team({
      name: "Green",
      rgb: [0, 255, 0]
    });

    Team.BLUE = new Team({
      name: "Blue",
      rgb: [0, 0, 255]
    });

    function Team(params) {
      _.extend(this, params);
    }

    Team.prototype.color = function(opacity) {
      if (opacity == null) {
        opacity = 1;
      }
      return "rgba(" + (this.rgb.join(',')) + ", " + opacity + ")";
    };

    return Team;

  })();

  window.Q = Quintus({
    development: true
  }).include("Sprites, Math, Scenes, Input, 2D, Touch, UI").setup({
    maximize: true,
    scaleToFit: true
  }).controls().touch();

  Game = (function() {
    Game.assets = ["star.png", "planet0.png", "planet1.png"];

    Game.start = function() {
      if (this.started == null) {
        this.started = new $.Deferred;
      }
      if (this.started.state() === 'resolved') {
        return;
      }
      console.log('starting game...');
      this.instance = new Game();
      return window.g = this.instance;
    };

    function Game() {
      this.Q = window.Q;
      this.Q.gravityY = 0;
      this.Q.gravityX = 0;
      this.Q.clearColor = "#000";
      this.loadAssets();
    }

    Game.prototype.loadAssets = function() {
      var assetList;
      assetList = Game.assets.map(function(fileName) {
        return "/assets/images/" + fileName;
      }).join(', ');
      return this.Q.load(assetList, (function(_this) {
        return function() {
          _this.Q.stageScene("level1");
          return Game.started.resolveWith(_this);
        };
      })(this));
    };

    return Game;

  })();

  $(document).ready(function() {
    return Game.start();
  });

  Q.component('shipBuilder', {
    added: function() {
      this.timer = setInterval(this.build.bind(this), this.entity.p.buildRate || 1000);
      return this._emitToCoordIndex = 0;
    },
    stopBuilding: function() {
      return clearInterval(this.timer);
    },
    nextCoords: function() {
      var coords, dist, ref, x, y;
      dist = 50;
      ref = this.entity.p, x = ref.x, y = ref.y;
      coords = [
        {
          x: x + dist,
          y: y + dist
        }, {
          x: x - dist,
          y: y + dist
        }, {
          x: x + dist,
          y: y - dist
        }, {
          x: x - dist,
          y: y - dist
        }
      ];
      return coords[this._emitToCoordIndex++ % coords.length];
    },
    build: function() {
      var coords, ref, team, x, y;
      ref = this.entity.p, team = ref.team, x = ref.x, y = ref.y;
      coords = this.nextCoords();
      this.entity.stage.insert(new Q.Marker(coords));
      return this.entity.stage.insert(new Q.Ship({
        x: x,
        y: y,
        team: team,
        targetXY: coords
      }));
    }
  });

  Q.Sprite.extend('Marker', {
    init: function(p) {
      return this._super(_.defaults(p, {
        asset: '/assets/images/star.png',
        type: Q.SPRITE_NONE,
        gap: 1
      }));
    },
    draw: function(ctx) {
      var x, y;
      ctx.beginPath();
      ctx.strokeStyle = "rgba(255,255,0,1)";
      ctx.lineWidth = 2;
      x = this.asset().width / 2;
      y = this.asset().height / 2;
      ctx.moveTo(0, 0 - this.p.gap);
      ctx.lineTo(0, y * -1);
      ctx.moveTo(0, this.p.gap);
      ctx.lineTo(0, y);
      ctx.moveTo(0 - this.p.gap, 0);
      ctx.lineTo(x * -1, 0);
      ctx.moveTo(this.p.gap, 0);
      ctx.lineTo(x, 0);
      return ctx.stroke();
    }
  });

  Q.Sprite.extend("Planet", {
    init: function(p) {
      var scale;
      scale = _.max([0.4, Math.ceil(Math.random() * 10) / 10]);
      console.log('SCALE', scale);
      this._super(Q._extend({
        asset: this.randomAsset(),
        scale: scale,
        team: Team.NONE,
        type: Q.SPRITE_NONE,
        buildRate: 500
      }, p));
      this.add('2d');
      this.add('shipBuilder');
      return this.on("hit.sprite", this.onCollision);
    },
    randomAsset: function() {
      var assets;
      assets = [0, 1].map(function(i) {
        return "/assets/images/planet" + i + ".png";
      });
      return assets[Math.floor(Math.random() * 10) % assets.length];
    },
    draw: function(ctx) {
      this._super(ctx);
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.beginPath();
      ctx.fillStyle = this.p.team.color(0.25);
      ctx.arc(0, 0, this.asset().width / 2, 0, 180);
      ctx.fill();
      return ctx.restore();
    },
    onCollision: (function(_this) {
      return function(collision) {
        return console.log('HIT');
      };
    })(this)
  });

  Q.Sprite.extend("Ship", {
    init: function(p) {
      this._super(_.defaults(p, {
        type: Q.SPRITE_NONE,
        team: Team.NONE,
        asset: '/assets/images/star.png',
        maxSpeed: 80,
        acceleration: 50,
        angle: 90,
        scale: 0.75,
        opacity: 0.5,
        lastX: p.x,
        lastY: p.y
      }));
      this.add('2d');
      return this.on("hit.sprite", this.onCollision);
    },
    draw: function(ctx) {
      ctx.globalCompositeOperation = 'lighter';
      this._super(ctx);
      ctx.save();
      ctx.beginPath();
      ctx.fillStyle = this.p.team.color(0.75);
      ctx.arc(0, 0, this.asset().width / 2, 0, 180);
      ctx.fill();
      return ctx.restore();
    },
    targetCoords: function() {
      if (this.p.target != null) {
        return _.pick(this.p.target.p, 'x', 'y', 'vx', 'vy');
      } else {
        return this.p.targetXY;
      }
    },
    stop: function() {
      return this.p.vx = this.p.vy = 0;
    },
    applyInertia: function(speed) {
      var limited, shouldAccelerate, shouldChange, shouldDecelerate;
      shouldChange = (function(_this) {
        return function() {
          return true;
        };
      })(this);
      shouldAccelerate = (function(_this) {
        return function() {
          return speed < _this.p.maxSpeed && shouldChange();
        };
      })(this);
      shouldDecelerate = (function(_this) {
        return function() {
          return speed >= _this.p.maxSpeed && shouldChange();
        };
      })(this);
      limited = (function(_this) {
        return function(speed) {
          return _.min([_this.p.maxSpeed, speed]);
        };
      })(this);
      return limited(speed);
    },
    step: function(dt) {
      var mod, target, targetAngle, xSpeed, ySpeed;
      if (!(target = this.targetCoords())) {
        return;
      }
      targetAngle = Q.angle(this.p.x, this.p.y, target.x, target.y);
      xSpeed = Q.offsetX(targetAngle, this.p.acceleration) * dt * this.p.acceleration;
      ySpeed = Q.offsetY(targetAngle, this.p.acceleration) * dt * this.p.acceleration;
      mod = {
        x: targetAngle >= 180 ? -1 : 1,
        y: targetAngle >= 90 || targetAngle <= 270 ? -1 : 1
      };
      this.p.angle = targetAngle;
      this.p.vx = this.applyInertia(xSpeed) * mod.x;
      return this.p.vy = this.applyInertia(ySpeed) * mod.y;
    },
    onCollision: (function(_this) {
      return function(collision) {
        return console.log('HIT');
      };
    })(this)
  });

  Q.Sprite.extend('Star', {
    init: function(p) {
      return this._super(p, {
        x: Math.random() * Q.width,
        y: Math.random() * Q.height,
        scale: Math.max(Math.random(), .3),
        asset: '/assets/images/star.png',
        type: Q.SPRITE_NONE
      });
    }
  });

  Q.scene("endGame", function(stage) {
    var button, container, label;
    container = stage.insert(new Q.UI.Container({
      x: Q.width / 2,
      y: Q.height / 2,
      fill: "rgba(0,0,0,0.5)"
    }));
    button = container.insert(new Q.UI.Button({
      x: 0,
      y: 0,
      fill: "#CCCCCC",
      label: "Play Again"
    }));
    label = container.insert(new Q.UI.Text({
      x: 10,
      y: -10 - button.p.h,
      label: stage.options.label
    }));
    button.on("click", function() {
      Q.clearStages();
      return Q.stageScene('level1');
    });
    return container.fit(20);
  });

  Q.scene("level1", function(stage) {
    var j, planetOne, planets, ref;
    planets = [
      planetOne = new Q.Planet({
        x: 300,
        y: 100,
        team: Team.RED
      })
    ];
    for (j = 1, ref = Q.width * Q.height / 10000; 1 <= ref ? j <= ref : j >= ref; 1 <= ref ? j++ : j--) {
      stage.insert(new Q.Star);
    }
    planets.forEach(function(p) {
      return stage.insert(p);
    });
    return stage.add("viewport");
  });

}).call(this);
